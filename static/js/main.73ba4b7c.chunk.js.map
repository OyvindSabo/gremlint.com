{"version":3,"sources":["router.ts","components/FadeIn.tsx","styleVariables.ts","components/NavigationButton.tsx","components/Navigator.tsx","libs/gremlint/types.ts","libs/reduced-state/dispatch.ts","libs/reduced-state/reducedState.ts","store/initialState.ts","libs/gremlint/utils.ts","libs/gremlint/formatSyntaxTree/utils.ts","libs/gremlint/recreateQueryOnelinerFromSyntaxTree.ts","libs/gremlint/consts.ts","libs/gremlint/formatSyntaxTree/formatTraversal/getStepGroups/utils.ts","libs/gremlint/formatSyntaxTree/formatTraversal/getStepGroups/index.ts","libs/gremlint/formatSyntaxTree/index.ts","libs/gremlint/formatSyntaxTree/formatTraversal/index.ts","libs/gremlint/formatSyntaxTree/formatMethod.ts","libs/gremlint/formatSyntaxTree/formatString.ts","libs/gremlint/formatSyntaxTree/formatWord.ts","libs/gremlint/parseToSyntaxTree.ts","libs/gremlint/recreateQueryStringFromFormattedSyntaxTree.ts","libs/gremlint/index.ts","store/actions.ts","store/index.ts","store/reducers.ts","store/routines.ts","components/QueryInput.tsx","components/TextButton.tsx","components/CodePreview.tsx","libs/reduced-state/useReducedState.ts","components/Toggle.tsx","views/QueryFormatter/AdvancedOptions.tsx","views/QueryFormatter/index.tsx","components/Paragraph.tsx","components/Title.tsx","components/Spacer.ts","components/StyleGuideRule.tsx","views/StyleGuide/rules.ts","views/StyleGuide/index.tsx","components/LoadingAnimation.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["router","createRouter","FadeInWrapper","styled","div","$opacity","FadeIn","children","props","useState","opacity","setOpacity","useEffect","setTimeout","textColor","inputTextColor","highlightedTextColor","white","NavigationButtonWrapper","span","NavigationButtonLink","a","$isSelected","NavigationButton","isSelected","href","label","TokenType","NavigatorWrapper","NavigatorCenterContainer","Spacer","Navigator","matchedRoute","dispatch","action","payload","window","dispatchEvent","CustomEvent","detail","createReducedState","initialState","reducers","routines","state","changeListeners","Object","entries","forEach","reducer","addEventListener","event","nextState","changeListener","routine","addChangeListener","changeListenerToBeAdded","removeChangeListener","changeListenerToBeRemoved","filter","queryInput","queryOutput","shouldShowAdvancedOptions","indentation","maxLineLength","shouldPlaceDotsAfterLineBreaks","last","array","slice","pipe","fns","value","reduce","fn","spaces","numberOfSpaces","Array","join","recreateQueryOnelinerFromSyntaxTree","syntaxTree","type","Traversal","steps","map","Method","method","arguments","String","string","Word","word","withZeroIndentation","config","withIncreasedIndentation","indentationIncrease","withDotInfo","shouldStartWithDot","shouldEndWithDot","withZeroDotInfo","withNoEndDotInfo","STEP_MODULATORS","isTraversalSource","step","isModulator","includes","getStepGroups","formatSyntaxTree","index","stepsInStepGroup","stepGroups","isFirstStepInStepGroup","length","isLastStep","nextStepIsModulator","stepsWithSubsequentModulators","aggregator","hasReachedFinalModulator","stepGroupIndentationIncrease","lineIsTooLongWithSubsequentModulators","isFirstStepGroup","isLastStepGroup","stepIndex","formatTraversal","argumentGroups","argumentsShouldStartOnNewLine","Boolean","formatMethod","formatString","formatWord","tokenizeOnTopLevelComma","query","parenthesesCount","squareBracketCount","curlyBracketCount","isInsideSingleQuoteString","split","char","fromCharCode","token","trim","tokenizeOnTopLevelParentheses","isWrappedInParentheses","charAt","trimParentheses","expression","parseToSyntaxTree","tokens","tokenizeOnTopLevelPunctuation","isMethodInvocation","methodToken","argumentTokens","getMethodTokenAndArgumentTokensFromMethodInvocation","substr","isString","recreateQueryStringFromFormattedSyntaxTree","stepGroup","args","formatQuery","SET_QUERY_INPUT","FORMAT_QUERY","TOGGLE_SHOULD_SHOW_ADVANCED_OPTIONS","SET_INDENTATION","SET_MAX_LINE_LENGTH","SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS","store","unparsedIndentation","parseInt","isNaN","unparsedMaxLineLength","QueryInputWrapper","QueryInputTextArea","textarea","QueryInput","onChange","rows","TextButtonWrapper","TextButtonButton","button","TextButton","onClick","CodePreviewWrapper","CodePreviewBox","Code","CodeRuler","$maxLineLength","CodePreview","useReducedState","reducedState","setState","ToggleContainer","$height","$width","Option","SelectedOption","$checked","Toggle","width","height","checked","labels","unchecked","AdvancedOptionRowWrapper","AdvancedOptionLabel","AdvancedOptionInput","input","AdvancedOptions","min","max","target","ExpandableAdvancedOptionsWrapper","$isExpanded","QueryFormatter","ParagraphWrapper","$hasContent","css","ParagraphContent","Paragraph","TitleWrapper","TitleContent","Title","StyleGuideRule","title","explanation","example","rules","StyleGuide","LoadingAnimationWrapper","GrayscaleImageWrapper","ColoredImageWrapper","$loadingCompletion","Image","img","LoadingAnimation","onLoadingComplete","loadingCompletion","setLoadingCompletion","coloredImageHasLoaded","setColoredImageHasLoaded","grayscaleImageHasLoaded","setGrayscaleImageHasLoaded","src","onLoad","ViewWrapper","App","useRouter","loadingComplete","setLoadingComplete","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.73ba4b7c.chunk.js","sourcesContent":["import createRouter from 'sharp-router';\n\nconst router = createRouter({\n  '/': 'Gremlint - Query formatter',\n  '/style-guide': 'Gremlint - Style guide',\n});\n\nexport default router;\n","import React, { HTMLAttributes, useEffect, useState } from 'react';\nimport styled from 'styled-components';\n\nconst FadeInWrapper = styled.div<{ $opacity: number }>`\n  opacity: ${({ $opacity }) => $opacity};\n`;\n\nconst FadeIn = ({ children, ...props }: HTMLAttributes<HTMLDivElement>) => {\n  const [opacity, setOpacity] = useState(0);\n\n  useEffect(() => {\n    setTimeout(() => setOpacity(1));\n  }, []);\n\n  return (\n    <FadeInWrapper $opacity={opacity} {...props}>\n      {children}\n    </FadeInWrapper>\n  );\n};\n\nexport default FadeIn;\n","export const borderColor = 'lightgray';\nexport const textColor = 'slategray';\nexport const inputTextColor = 'darkslategray';\nexport const highlightedTextColor = 'darkslategray';\nexport const disabledTextColor = 'lightgray';\nexport const highlightColor = 'yellowgreen';\nexport const white = 'white';\n","import React from 'react';\nimport styled from 'styled-components';\nimport {\n  highlightColor,\n  highlightedTextColor,\n  textColor,\n} from '../styleVariables';\n\nconst NavigationButtonWrapper = styled.span`\n  display: inline-block;\n  vertical-align: bottom;\n  padding: 10px;\n  box-sizing: border-box;\n  height: 40px;\n  width: 160px;\n`;\n\nconst NavigationButtonLink = styled.a<{ $isSelected: boolean }>`\n  text-decoration: none;\n  display: inline-block;\n  height: 20px;\n  line-height: 20px;\n  font-size: 15px;\n  color: ${({ $isSelected }) =>\n    $isSelected ? highlightedTextColor : textColor};\n  border-bottom: ${({ $isSelected }) =>\n    $isSelected ? `2px solid ${highlightColor}` : 'none'};\n  &:hover {\n    color: ${highlightedTextColor};\n  }\n`;\n\ntype NavigationButtonProps = {\n  isSelected: boolean;\n  href: string;\n  label: string;\n};\n\nconst NavigationButton = ({\n  isSelected,\n  href,\n  label,\n}: NavigationButtonProps) => (\n  <NavigationButtonWrapper>\n    <NavigationButtonLink href={href} $isSelected={isSelected}>\n      {label}\n    </NavigationButtonLink>\n  </NavigationButtonWrapper>\n);\n\nexport default NavigationButton;\n","import React from 'react';\nimport styled from 'styled-components';\nimport NavigationButton from './NavigationButton';\nimport { white } from '../styleVariables';\n\nconst NavigatorWrapper = styled.div`\n  background: ${white};\n  box-shadow: ${white} 0 0 10px;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  z-index: 1;\n`;\n\nconst NavigatorCenterContainer = styled.div`\n  width: min(800px, 100vw);\n  margin-left: calc(50vw - min(400px, 50vw));\n`;\n\nconst Spacer = styled.div`\n  height: 40px;\n`;\n\ntype NavigatorProps = {\n  matchedRoute: string;\n};\n\nconst Navigator = ({ matchedRoute }: NavigatorProps) => (\n  <div>\n    <NavigatorWrapper>\n      <NavigatorCenterContainer>\n        <NavigationButton\n          isSelected={matchedRoute === '/'}\n          label=\"Query formatter\"\n          href=\"#/\"\n        />\n        <NavigationButton\n          isSelected={matchedRoute === '/style-guide'}\n          label=\"Style guide\"\n          href=\"#/style-guide\"\n        />\n      </NavigatorCenterContainer>\n    </NavigatorWrapper>\n    <Spacer />\n  </div>\n);\n\nexport default Navigator;\n","export type GremlintConfig = {\n  indentation: number;\n  maxLineLength: number;\n  shouldPlaceDotsAfterLineBreaks: boolean;\n};\n\nexport type DotInfo = {\n  shouldEndWithDot?: boolean;\n  shouldStartWithDot?: boolean;\n};\n\nexport type ExtendedGremlintConfig = GremlintConfig & DotInfo;\n\nexport enum TokenType {\n  Method = 'METHOD',\n  String = 'STRING',\n  Word = 'WORD',\n  Traversal = 'TRAVERSAL',\n}\n\nexport type UnformattedTraversalSyntaxTree = {\n  type: TokenType.Traversal;\n  steps: UnformattedSyntaxTree[];\n};\n\nexport type UnformattedMethodSyntaxTree = {\n  type: TokenType.Method;\n  method: UnformattedSyntaxTree;\n  arguments: UnformattedSyntaxTree[];\n};\n\nexport type UnformattedStringSyntaxTree = {\n  type: TokenType.String;\n  string: string;\n};\n\nexport type UnformattedWordSyntaxTree = {\n  type: TokenType.Word;\n  word: string;\n};\n\nexport type UnformattedSyntaxTree =\n  | UnformattedMethodSyntaxTree\n  | UnformattedStringSyntaxTree\n  | UnformattedWordSyntaxTree\n  | UnformattedTraversalSyntaxTree;\n\nexport type GremlinStepGroup = {\n  steps: FormattedSyntaxTree[];\n};\n\nexport type FormattedTraversalSyntaxTree = {\n  type: TokenType.Traversal;\n  steps: UnformattedSyntaxTree[];\n  stepGroups: GremlinStepGroup[];\n  indentation: number;\n};\n\nexport type FormattedMethodSyntaxTree = {\n  type: TokenType.Method;\n  method: FormattedSyntaxTree;\n  arguments: UnformattedSyntaxTree[];\n  argumentGroups: FormattedSyntaxTree[][];\n  argumentsShouldStartOnNewLine: boolean;\n  indentation: number;\n  shouldStartWithDot: boolean;\n  shouldEndWithDot: boolean;\n};\n\nexport type FormattedStringSyntaxTree = {\n  type: TokenType.String;\n  string: string;\n  indentation: number;\n};\n\nexport type FormattedWordSyntaxTree = {\n  type: TokenType.Word;\n  word: string;\n  indentation: number;\n  shouldStartWithDot: boolean;\n  shouldEndWithDot: boolean;\n};\n\nexport type FormattedSyntaxTree =\n  | FormattedTraversalSyntaxTree\n  | FormattedMethodSyntaxTree\n  | FormattedStringSyntaxTree\n  | FormattedWordSyntaxTree;\n\nexport type GremlinSyntaxTreeFormatter = (\n  config: GremlintConfig,\n) => (syntaxTree: UnformattedSyntaxTree) => FormattedSyntaxTree;\n","export const dispatch = (action: string, payload?: any) => {\n  window.dispatchEvent(new CustomEvent(action, { detail: payload }));\n};\n","import { ChangeListener, CreateReducedStateProps } from './types';\n\nconst createReducedState = <T>({\n  initialState,\n  reducers,\n  routines,\n}: CreateReducedStateProps<T>) => {\n  let state = initialState;\n  let changeListeners: ChangeListener<T>[] = [];\n\n  Object.entries(reducers).forEach(([action, reducer]) => {\n    window.addEventListener(action, ((event: CustomEvent) => {\n      const nextState = reducer(state, event.detail);\n      state = nextState;\n      changeListeners.forEach((changeListener) => changeListener(state));\n    }) as EventListener);\n  });\n\n  Object.entries(routines).forEach(([action, routine]) => {\n    window.addEventListener(action, ((event: CustomEvent) => {\n      routine(state, event.detail);\n    }) as EventListener);\n  });\n\n  const addChangeListener = (changeListenerToBeAdded: ChangeListener<T>) => {\n    changeListeners = [...changeListeners, changeListenerToBeAdded];\n  };\n\n  const removeChangeListener = (\n    changeListenerToBeRemoved: ChangeListener<T>,\n  ) => {\n    changeListeners = changeListeners.filter(\n      (changeListener) => changeListener !== changeListenerToBeRemoved,\n    );\n  };\n\n  return { state, addChangeListener, removeChangeListener };\n};\n\nexport default createReducedState;\n","const initialState = {\n  queryInput: '',\n  queryOutput: '',\n  shouldShowAdvancedOptions: false,\n  indentation: 0,\n  maxLineLength: 72,\n  shouldPlaceDotsAfterLineBreaks: false,\n};\n\nexport default initialState;\n","export const last = <T>(array: T[]) => array.slice(-1)[0];\n\nexport const pipe = (...fns: ((value: any) => any)[]) => (value: any) => fns.reduce((value, fn) => fn(value), value);\n\nexport const spaces = (numberOfSpaces: number): string => Array(numberOfSpaces + 1).join(' ');\n","import { DotInfo, ExtendedGremlintConfig, GremlintConfig } from '../types';\n\nexport const withIndentation = (indentation: number) => (config: GremlintConfig): GremlintConfig => ({\n  ...config,\n  indentation,\n});\n\nexport const withZeroIndentation = withIndentation(0);\n\nexport const withIncreasedIndentation = (indentationIncrease: number) => (config: GremlintConfig): GremlintConfig => ({\n  ...config,\n  indentation: config.indentation + indentationIncrease,\n});\n\nexport const withDotInfo = ({ shouldStartWithDot, shouldEndWithDot }: DotInfo) => (\n  config: GremlintConfig,\n): ExtendedGremlintConfig => ({\n  ...config,\n  shouldStartWithDot,\n  shouldEndWithDot,\n});\n\nexport const withZeroDotInfo = (config: GremlintConfig): ExtendedGremlintConfig => ({\n  ...config,\n  shouldStartWithDot: false,\n  shouldEndWithDot: false,\n});\n\nexport const withNoEndDotInfo = (config: GremlintConfig): ExtendedGremlintConfig => ({\n  ...config,\n  shouldEndWithDot: false,\n});\n","import {\n  TokenType,\n  UnformattedMethodSyntaxTree,\n  UnformattedStringSyntaxTree,\n  UnformattedTraversalSyntaxTree,\n  UnformattedWordSyntaxTree,\n} from './types';\nimport { spaces } from './utils';\n\ntype GremlinOnelinerSyntaxTree =\n  | Pick<UnformattedTraversalSyntaxTree, 'type' | 'steps'>\n  | Pick<UnformattedMethodSyntaxTree, 'type' | 'method' | 'arguments'>\n  | Pick<UnformattedStringSyntaxTree, 'type' | 'string'>\n  | Pick<UnformattedWordSyntaxTree, 'type' | 'word'>;\n\nconst recreateQueryOnelinerFromSyntaxTree = (indentation: number = 0) => (\n  syntaxTree: GremlinOnelinerSyntaxTree,\n): string => {\n  switch (syntaxTree.type) {\n    case TokenType.Traversal:\n      return spaces(indentation) + syntaxTree.steps.map(recreateQueryOnelinerFromSyntaxTree()).join('.');\n    case TokenType.Method:\n      return (\n        spaces(indentation) +\n        recreateQueryOnelinerFromSyntaxTree()(syntaxTree.method) +\n        '(' +\n        syntaxTree.arguments.map(recreateQueryOnelinerFromSyntaxTree()).join(', ') +\n        ')'\n      );\n    case TokenType.String:\n      return spaces(indentation) + syntaxTree.string;\n    case TokenType.Word:\n      return spaces(indentation) + syntaxTree.word;\n  }\n};\n\nexport default recreateQueryOnelinerFromSyntaxTree;\n","export const STEP_MODULATORS = [\n  'as',\n  'as_',\n  'by',\n  'emit',\n  'option',\n  'from',\n  'from_',\n  'to',\n  'read',\n  'times',\n  'until',\n  'with',\n  'with_',\n  'write',\n];\n","import { FormattedSyntaxTree, TokenType, UnformattedSyntaxTree } from '../../../types';\nimport { STEP_MODULATORS } from '../../../consts';\n\nexport const isTraversalSource = (step: FormattedSyntaxTree): boolean => {\n  return step.type === TokenType.Word && step.word === 'g';\n};\n\nexport const isModulator = (step: UnformattedSyntaxTree | FormattedSyntaxTree): boolean => {\n  if (step.type !== TokenType.Method) return false;\n  if (step.method.type !== TokenType.Word) return false;\n  return STEP_MODULATORS.includes(step.method.word);\n};\n","import recreateQueryOnelinerFromSyntaxTree from '../../../recreateQueryOnelinerFromSyntaxTree';\nimport {\n  GremlinStepGroup,\n  FormattedSyntaxTree,\n  GremlinSyntaxTreeFormatter,\n  GremlintConfig,\n  TokenType,\n  UnformattedSyntaxTree,\n} from '../../../types';\nimport { pipe } from '../../../utils';\nimport { withDotInfo, withIncreasedIndentation, withZeroIndentation } from '../../utils';\nimport { isModulator, isTraversalSource } from './utils';\n\nexport const getStepGroups = (\n  formatSyntaxTree: GremlinSyntaxTreeFormatter,\n  steps: UnformattedSyntaxTree[],\n  config: GremlintConfig,\n): GremlinStepGroup[] => {\n  const { stepGroups } = steps.reduce(\n    ({ stepsInStepGroup, stepGroups }, step, index, steps) => {\n      const isFirstStepInStepGroup = !stepsInStepGroup.length;\n\n      const isLastStep = index === steps.length - 1;\n      const nextStepIsModulator = !isLastStep && isModulator(steps[index + 1]);\n      const stepsWithSubsequentModulators = steps.slice(index + 1).reduce(\n        (aggregator, step) => {\n          const { stepsInStepGroup, hasReachedFinalModulator } = aggregator;\n          if (hasReachedFinalModulator) return aggregator;\n          if (isModulator(step)) {\n            return {\n              ...aggregator,\n              stepsInStepGroup: [...stepsInStepGroup, step],\n            };\n          }\n          return { ...aggregator, hasReachedFinalModulator: true };\n        },\n        {\n          stepsInStepGroup: [...stepsInStepGroup, step],\n          hasReachedFinalModulator: false,\n        },\n      ).stepsInStepGroup;\n\n      const stepGroupIndentationIncrease = (() => {\n        const traversalSourceIndentationIncrease = stepGroups[0] && isTraversalSource(stepGroups[0].steps[0]) ? 2 : 0;\n        const modulatorIndentationIncrease = isModulator([...stepsInStepGroup, step][0]) ? 2 : 0;\n        const indentationIncrease = traversalSourceIndentationIncrease + modulatorIndentationIncrease;\n        return indentationIncrease;\n      })();\n\n      const recreatedQueryWithSubsequentModulators = recreateQueryOnelinerFromSyntaxTree(\n        config.indentation + stepGroupIndentationIncrease,\n      )({\n        type: TokenType.Traversal,\n        steps: stepsWithSubsequentModulators,\n      });\n\n      const lineIsTooLongWithSubsequentModulators =\n        recreatedQueryWithSubsequentModulators.length > config.maxLineLength;\n\n      // If the first step in a group is a modulator, then it must also be the last step in the group\n      const shouldBeLastStepInStepGroup =\n        isLastStep ||\n        (isFirstStepInStepGroup && isModulator(step)) ||\n        (step.type === TokenType.Method && !(nextStepIsModulator && !lineIsTooLongWithSubsequentModulators));\n\n      // If it should be the last step in a line\n      // We don't want to newline after words which are not methods. For\n      // instance, g.V() should be one one line, as should __.as\n      if (shouldBeLastStepInStepGroup) {\n        const isFirstStepGroup = stepGroups.length === 0;\n        const isLastStepGroup = index === steps.length - 1;\n\n        // If it is the first (and last) step in a line, format it with\n        // indentation, otherwise, remove the indentation\n        if (isFirstStepInStepGroup) {\n          const traversalSourceIndentationIncrease = stepGroups[0] && isTraversalSource(stepGroups[0].steps[0]) ? 2 : 0;\n          const modulatorIndentationIncrease = isModulator(step) ? 2 : 0;\n          const indentationIncrease = traversalSourceIndentationIncrease + modulatorIndentationIncrease;\n\n          // This is the only step in the step group, so it is the first step in\n          // the step group. It should only start with a dot if it is not the\n          // first stepGroup and config.shouldPlaceDotsAfterLineBreaks\n          const shouldStartWithDot = !isFirstStepGroup && config.shouldPlaceDotsAfterLineBreaks;\n\n          // It is the last step in a group and should only end with dot if not\n          // config.shouldPlaceDotsAfterLineBreaks this is not the last step in\n          // steps\n          const shouldEndWithDot = !isLastStepGroup && !config.shouldPlaceDotsAfterLineBreaks;\n\n          return {\n            stepsInStepGroup: [],\n            stepGroups: [\n              ...stepGroups,\n              {\n                steps: [\n                  formatSyntaxTree(\n                    pipe(\n                      withIncreasedIndentation(indentationIncrease),\n                      withDotInfo({ shouldStartWithDot, shouldEndWithDot }),\n                    )(config),\n                  )(step),\n                ],\n              },\n            ],\n          };\n        }\n        // If it is the last (and also not first) step in a group\n        return (() => {\n          // This is not the first step in the step group, so it should not\n          // start with a dot\n          const shouldStartWithDot = false;\n\n          // It is the last step in a group and should only end with dot if not\n          // config.shouldPlaceDotsAfterLineBreaks this is not the last step in\n          // steps\n          const shouldEndWithDot = !isLastStepGroup && !config.shouldPlaceDotsAfterLineBreaks;\n\n          return {\n            stepsInStepGroup: [],\n            stepGroups: [\n              ...stepGroups,\n              {\n                steps: [\n                  ...stepsInStepGroup,\n                  formatSyntaxTree(\n                    pipe(withZeroIndentation, withDotInfo({ shouldStartWithDot, shouldEndWithDot }))(config),\n                  )(step),\n                ],\n              },\n            ],\n          };\n        })();\n      }\n\n      // If it is the first step in a group and also not the last one, format it\n      // with indentation, otherwise, remove the indentation\n      if (isFirstStepInStepGroup) {\n        const indentationIncrease = stepGroups[0] && isTraversalSource(stepGroups[0].steps[0]) ? 2 : 0;\n\n        const isFirstStepGroup = stepGroups.length === 0;\n\n        // It is the first step in a group and should start with a dot if it is\n        // not the first stepGroup and config.shouldPlaceDotsAfterLineBreaks\n        const shouldStartWithDot = !isFirstStepGroup && config.shouldPlaceDotsAfterLineBreaks;\n\n        // It is the first step in a group, but not the last, so it should not\n        // end with a dot.\n        const shouldEndWithDot = false;\n\n        return {\n          stepsInStepGroup: [\n            formatSyntaxTree(\n              pipe(\n                withIncreasedIndentation(indentationIncrease),\n                withDotInfo({ shouldStartWithDot, shouldEndWithDot }),\n              )(config),\n            )(step),\n          ],\n          stepGroups,\n        };\n      }\n      return (() => {\n        // If it is not the first step in a group and not the last one either\n        const shouldStartWithDot = false;\n        const shouldEndWithDot = false;\n        return {\n          stepsInStepGroup: [\n            ...stepsInStepGroup,\n            formatSyntaxTree(pipe(withZeroIndentation, withDotInfo({ shouldStartWithDot, shouldEndWithDot }))(config))(\n              step,\n            ),\n          ],\n          stepGroups,\n        };\n      })();\n    },\n    {\n      stepsInStepGroup: [] as FormattedSyntaxTree[],\n      stepGroups: [] as GremlinStepGroup[],\n    },\n  );\n  return stepGroups;\n};\n","import { FormattedSyntaxTree, GremlintConfig, TokenType, UnformattedSyntaxTree } from '../types';\nimport { formatMethod } from './formatMethod';\nimport { formatString } from './formatString';\nimport { formatTraversal } from './formatTraversal';\nimport { formatWord } from './formatWord';\n\nexport const formatSyntaxTree = (config: GremlintConfig) => (\n  syntaxTree: UnformattedSyntaxTree,\n): FormattedSyntaxTree => {\n  switch (syntaxTree.type) {\n    case TokenType.Traversal:\n      return formatTraversal(formatSyntaxTree)(config)(syntaxTree);\n    case TokenType.Method:\n      return formatMethod(formatSyntaxTree)(config)(syntaxTree);\n    case TokenType.String:\n      return formatString(config)(syntaxTree);\n    case TokenType.Word:\n      return formatWord(config)(syntaxTree);\n  }\n};\n","import recreateQueryOnelinerFromSyntaxTree from '../../recreateQueryOnelinerFromSyntaxTree';\nimport {\n  FormattedTraversalSyntaxTree,\n  GremlinSyntaxTreeFormatter,\n  GremlintConfig,\n  TokenType,\n  UnformattedTraversalSyntaxTree,\n} from '../../types';\nimport { withZeroIndentation } from '../utils';\nimport { getStepGroups } from './getStepGroups';\n\n// Groups steps into step groups and adds an indentation property\nexport const formatTraversal = (formatSyntaxTree: GremlinSyntaxTreeFormatter) => (config: GremlintConfig) => (\n  syntaxTree: UnformattedTraversalSyntaxTree,\n): FormattedTraversalSyntaxTree => {\n  const recreatedQuery = recreateQueryOnelinerFromSyntaxTree(config.indentation)(syntaxTree);\n  if (recreatedQuery.length <= config.maxLineLength) {\n    return {\n      type: TokenType.Traversal,\n      steps: syntaxTree.steps,\n      stepGroups: [\n        {\n          steps: syntaxTree.steps.map((step, stepIndex) =>\n            formatSyntaxTree(stepIndex === 0 ? config : withZeroIndentation(config))(step),\n          ),\n        },\n      ],\n      indentation: 0,\n    };\n  }\n  return {\n    type: TokenType.Traversal,\n    steps: syntaxTree.steps,\n    stepGroups: getStepGroups(formatSyntaxTree, syntaxTree.steps, config),\n    indentation: 0,\n  };\n};\n","import recreateQueryOnelinerFromSyntaxTree from '../recreateQueryOnelinerFromSyntaxTree';\nimport {\n  ExtendedGremlintConfig,\n  FormattedMethodSyntaxTree,\n  GremlinSyntaxTreeFormatter,\n  TokenType,\n  UnformattedMethodSyntaxTree,\n} from '../types';\nimport { pipe } from '../utils';\nimport { withIncreasedIndentation, withNoEndDotInfo, withZeroDotInfo, withZeroIndentation } from './utils';\n\n// Groups arguments into argument groups an adds an indentation property\nexport const formatMethod = (formatSyntaxTree: GremlinSyntaxTreeFormatter) => (config: ExtendedGremlintConfig) => (\n  syntaxTree: UnformattedMethodSyntaxTree,\n): FormattedMethodSyntaxTree => {\n  const recreatedQuery = recreateQueryOnelinerFromSyntaxTree(config.indentation)(syntaxTree);\n  if (recreatedQuery.length <= config.maxLineLength) {\n    return {\n      type: TokenType.Method,\n      method: formatSyntaxTree(withNoEndDotInfo(config))(syntaxTree.method),\n      // The arguments property is here so that the resulted syntax tree can\n      // still be understood by recreateQueryOnelinerFromSyntaxTree\n      arguments: syntaxTree.arguments,\n      argumentGroups: [syntaxTree.arguments.map(formatSyntaxTree(pipe(withZeroIndentation, withZeroDotInfo)(config)))],\n      argumentsShouldStartOnNewLine: false,\n      indentation: config.indentation,\n      shouldStartWithDot: false,\n      shouldEndWithDot: Boolean(config.shouldEndWithDot),\n    };\n  }\n  // shouldEndWithDot has to reside on the method object, so the end dot can be\n  // placed after the method parentheses. shouldStartWithDot has to be passed on\n  // further down so the start dot can be placed after the indentation.\n  return {\n    type: TokenType.Method,\n    method: formatSyntaxTree(withNoEndDotInfo(config))(syntaxTree.method),\n    arguments: syntaxTree.arguments,\n    argumentGroups: syntaxTree.arguments.map((step) => [\n      formatSyntaxTree(pipe(withIncreasedIndentation(2), withZeroDotInfo)(config))(step),\n    ]),\n    argumentsShouldStartOnNewLine: true,\n    shouldStartWithDot: false,\n    shouldEndWithDot: Boolean(config.shouldEndWithDot),\n    indentation: 0,\n  };\n};\n","import { FormattedStringSyntaxTree, GremlintConfig, TokenType, UnformattedStringSyntaxTree } from '../types';\n\nexport const formatString = (config: GremlintConfig) => (\n  syntaxTree: UnformattedStringSyntaxTree,\n): FormattedStringSyntaxTree => {\n  return {\n    type: TokenType.String,\n    string: syntaxTree.string,\n    indentation: config.indentation,\n  };\n};\n","import { ExtendedGremlintConfig, FormattedWordSyntaxTree, TokenType, UnformattedWordSyntaxTree } from '../types';\n\nexport const formatWord = (config: ExtendedGremlintConfig) => (\n  syntaxTree: UnformattedWordSyntaxTree,\n): FormattedWordSyntaxTree => {\n  return {\n    type: TokenType.Word,\n    word: syntaxTree.word,\n    indentation: config.indentation,\n    shouldStartWithDot: Boolean(config.shouldStartWithDot),\n    shouldEndWithDot: Boolean(config.shouldEndWithDot),\n  };\n};\n","import { TokenType, UnformattedSyntaxTree } from './types';\nimport { last, pipe } from './utils';\n\nconst tokenizeOnTopLevelPunctuation = (query: string): string[] => {\n  let word = '';\n  let parenthesesCount = 0;\n  let squareBracketCount = 0;\n  let curlyBracketCount = 0;\n  let isInsideSingleQuoteString = false;\n  query.split('').forEach((char) => {\n    if (char === '(' && !isInsideSingleQuoteString) {\n      parenthesesCount++;\n      word += '(';\n      return;\n    }\n    if (char === '[' && !isInsideSingleQuoteString) {\n      squareBracketCount++;\n      word += '[';\n      return;\n    }\n    if (char === '{' && !isInsideSingleQuoteString) {\n      curlyBracketCount++;\n      word += '{';\n      return;\n    }\n    if (char === ')' && !isInsideSingleQuoteString) {\n      parenthesesCount--;\n      word += ')';\n      return;\n    }\n    if (char === ']' && !isInsideSingleQuoteString) {\n      squareBracketCount--;\n      word += ']';\n      return;\n    }\n    if (char === '}' && !isInsideSingleQuoteString) {\n      curlyBracketCount--;\n      word += '}';\n      return;\n    }\n    if (char === \"'\") {\n      isInsideSingleQuoteString = !isInsideSingleQuoteString;\n      word += \"'\";\n      return;\n    }\n    if (char === '.') {\n      word +=\n        isInsideSingleQuoteString || parenthesesCount || squareBracketCount || curlyBracketCount\n          ? '.'\n          : String.fromCharCode(28);\n      return;\n    }\n    word += char;\n  });\n  return word\n    .split(String.fromCharCode(28))\n    .filter((token) => token !== '')\n    .map((token) => token.trim());\n};\n\nconst tokenizeOnTopLevelComma = (query: string): string[] => {\n  let word = '';\n  let parenthesesCount = 0;\n  let squareBracketCount = 0;\n  let curlyBracketCount = 0;\n  let isInsideSingleQuoteString = false;\n  query.split('').forEach((char) => {\n    if (char === '(' && !isInsideSingleQuoteString) {\n      parenthesesCount++;\n      word += '(';\n      return;\n    }\n    if (char === '[' && !isInsideSingleQuoteString) {\n      squareBracketCount++;\n      word += '[';\n      return;\n    }\n    if (char === '{' && !isInsideSingleQuoteString) {\n      curlyBracketCount++;\n      word += '{';\n      return;\n    }\n    if (char === ')' && !isInsideSingleQuoteString) {\n      parenthesesCount--;\n      word += ')';\n      return;\n    }\n    if (char === ']' && !isInsideSingleQuoteString) {\n      squareBracketCount--;\n      word += ']';\n      return;\n    }\n    if (char === '}' && !isInsideSingleQuoteString) {\n      curlyBracketCount--;\n      word += '}';\n      return;\n    }\n    if (char === \"'\") {\n      isInsideSingleQuoteString = !isInsideSingleQuoteString;\n      word += \"'\";\n      return;\n    }\n    if (char === ',') {\n      word +=\n        isInsideSingleQuoteString || parenthesesCount || squareBracketCount || curlyBracketCount\n          ? ','\n          : String.fromCharCode(28);\n      return;\n    }\n    word += char;\n  });\n  return word\n    .split(String.fromCharCode(28))\n    .filter((token) => token !== '')\n    .map((token) => token.trim());\n};\n\nconst tokenizeOnTopLevelParentheses = (query: string): string[] => {\n  let word = '';\n  let parenthesesCount = 0;\n  let squareBracketCount = 0;\n  let curlyBracketCount = 0;\n  let isInsideSingleQuoteString = false;\n  query.split('').forEach((char) => {\n    if (char === '(' && !isInsideSingleQuoteString) {\n      if (parenthesesCount === 0) {\n        word += String.fromCharCode(28);\n      }\n      parenthesesCount++;\n      word += '(';\n      return;\n    }\n    if (char === '[' && !isInsideSingleQuoteString) {\n      squareBracketCount++;\n      word += '[';\n      return;\n    }\n    if (char === '{' && !isInsideSingleQuoteString) {\n      curlyBracketCount++;\n      word += '{';\n      return;\n    }\n    if (char === ')' && !isInsideSingleQuoteString) {\n      parenthesesCount--;\n      word += ')';\n      return;\n    }\n    if (char === ']' && !isInsideSingleQuoteString) {\n      squareBracketCount--;\n      word += ']';\n      return;\n    }\n    if (char === '}' && !isInsideSingleQuoteString) {\n      curlyBracketCount--;\n      word += '}';\n      return;\n    }\n    if (char === \"'\") {\n      isInsideSingleQuoteString = !isInsideSingleQuoteString;\n      word += \"'\";\n      return;\n    }\n    word += char;\n  });\n  return word\n    .split(String.fromCharCode(28))\n    .filter((token) => token !== '')\n    .map((token) => token.trim());\n};\n\nconst isWrappedInParentheses = (token: string): boolean => {\n  if (token.length < 2) return false;\n  if (token.charAt(0) !== '(') return false;\n  if (token.slice(-1) !== ')') return false;\n  return true;\n};\n\nconst isString = (token: string): boolean => {\n  if (token.length < 2) return false;\n  if (token.charAt(0) !== token.substr(-1)) return false;\n  if (['\"', \"'\"].includes(token.charAt(0))) return true;\n  return false;\n};\n\nconst isMethodInvocation = (token: string): boolean => {\n  return pipe(tokenizeOnTopLevelParentheses, last, isWrappedInParentheses)(token);\n};\n\nconst trimParentheses = (expression: string): string => expression.slice(1, -1);\n\nconst getMethodTokenAndArgumentTokensFromMethodInvocation = (\n  token: string,\n): { methodToken: string; argumentTokens: string[] } => {\n  // The word before the first parenthesis is the method name\n  // The token may be a double application of a curried function, so we cannot\n  // assume that the first opening parenthesis is closed by the last closing\n  // parenthesis\n  const tokens = tokenizeOnTopLevelParentheses(token);\n  return {\n    methodToken: tokens.slice(0, -1).join(''),\n    argumentTokens: pipe(trimParentheses, tokenizeOnTopLevelComma)(tokens.slice(-1)[0]),\n  };\n};\n\nexport const parseToSyntaxTree = (query: string): UnformattedSyntaxTree => {\n  const tokens = tokenizeOnTopLevelPunctuation(query);\n  if (tokens.length === 1) {\n    const token = tokens[0];\n    if (isMethodInvocation(token)) {\n      const { methodToken, argumentTokens } = getMethodTokenAndArgumentTokensFromMethodInvocation(token);\n      return {\n        type: TokenType.Method,\n        method: parseToSyntaxTree(methodToken),\n        arguments: argumentTokens.map(parseToSyntaxTree),\n      };\n    }\n    if (isString(token)) {\n      return {\n        type: TokenType.String,\n        string: token,\n      };\n    }\n    return {\n      type: TokenType.Word,\n      word: token,\n    };\n  }\n  return {\n    type: TokenType.Traversal,\n    steps: tokens.map(parseToSyntaxTree),\n  };\n};\n","import { FormattedSyntaxTree, TokenType } from './types';\nimport { spaces } from './utils';\n\nexport const recreateQueryStringFromFormattedSyntaxTree = (syntaxTree: FormattedSyntaxTree): string => {\n  if (syntaxTree.type === TokenType.Traversal) {\n    return syntaxTree.stepGroups\n      .map((stepGroup) => stepGroup.steps.map(recreateQueryStringFromFormattedSyntaxTree).join('.'))\n      .join('\\n');\n  }\n  if (syntaxTree.type === TokenType.Method) {\n    return (\n      (syntaxTree.shouldStartWithDot ? '.' : '') +\n      [\n        recreateQueryStringFromFormattedSyntaxTree(syntaxTree.method) + '(',\n        syntaxTree.argumentGroups\n          .map((args) => args.map(recreateQueryStringFromFormattedSyntaxTree).join(', '))\n          .join(',\\n') +\n          ')' +\n          (syntaxTree.shouldEndWithDot ? '.' : ''),\n      ].join(syntaxTree.argumentsShouldStartOnNewLine ? '\\n' : '')\n    );\n  }\n  if (syntaxTree.type === TokenType.String) {\n    return spaces(syntaxTree.indentation) + syntaxTree.string;\n  }\n  if (syntaxTree.type === TokenType.Word) {\n    return (\n      spaces(syntaxTree.indentation) +\n      (syntaxTree.shouldStartWithDot ? '.' : '') +\n      syntaxTree.word +\n      (syntaxTree.shouldEndWithDot ? '.' : '')\n    );\n  }\n  // The following line is just here to convince TypeScript that the return type\n  // is string and not string | undefined.\n  return '';\n};\n","import { formatSyntaxTree } from './formatSyntaxTree';\nimport { parseToSyntaxTree } from './parseToSyntaxTree';\nimport { recreateQueryStringFromFormattedSyntaxTree } from './recreateQueryStringFromFormattedSyntaxTree';\nimport { GremlintConfig } from './types';\nimport { pipe } from './utils';\n\nexport const formatQuery = (\n  query: string,\n  { indentation = 0, maxLineLength = 80, shouldPlaceDotsAfterLineBreaks = false }: GremlintConfig,\n): string => {\n  return pipe(\n    parseToSyntaxTree,\n    formatSyntaxTree({ indentation, maxLineLength, shouldPlaceDotsAfterLineBreaks }),\n    recreateQueryStringFromFormattedSyntaxTree,\n  )(query);\n};\n","export const SET_QUERY_INPUT = 'SET_QUERY_INPUT';\nexport const FORMAT_QUERY = 'FORMAT_QUERY';\nexport const TOGGLE_SHOULD_SHOW_ADVANCED_OPTIONS =\n  'TOGGLE_SHOULD_SHOW_ADVANCED_OPTIONS';\nexport const SET_INDENTATION = 'SET_INDENTATION';\nexport const SET_MAX_LINE_LENGTH = 'SET_MAX_LINE_LENGTH';\nexport const SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS =\n  'SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS';\n","import createReducedState from '../libs/reduced-state';\nimport initialState from './initialState';\nimport reducers from './reducers';\nimport routines from './routines';\n\nconst store = createReducedState({ initialState, reducers, routines });\n\nexport default store;\n","import { formatQuery } from '../libs/gremlint';\nimport {\n  FORMAT_QUERY,\n  SET_INDENTATION,\n  SET_MAX_LINE_LENGTH,\n  SET_QUERY_INPUT,\n  SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS,\n  TOGGLE_SHOULD_SHOW_ADVANCED_OPTIONS,\n} from './actions';\nimport { State } from './types';\n\nconst handleSetQueryInput = (state: State, queryInput: string) => ({\n  ...state,\n  queryInput,\n});\n\nconst handleFormatQuery = (state: State) => ({\n  ...state,\n  queryOutput: formatQuery(state.queryInput, {\n    indentation: state.indentation,\n    maxLineLength: state.maxLineLength,\n    shouldPlaceDotsAfterLineBreaks: state.shouldPlaceDotsAfterLineBreaks,\n  }),\n});\n\nconst handleToggleShouldShowAdvancedOptions = (state: State) => ({\n  ...state,\n  shouldShowAdvancedOptions: !state.shouldShowAdvancedOptions,\n});\n\nconst handleSetIndentation = (state: State, unparsedIndentation: string) => {\n  const indentation = parseInt(unparsedIndentation);\n  if (isNaN(indentation)) return { ...state };\n  if (indentation < 0) return { ...state, indentation: 0 };\n  const { maxLineLength } = state;\n  if (indentation > maxLineLength) {\n    return { ...state, indentation: maxLineLength };\n  }\n  return { ...state, indentation };\n};\n\nconst handleSetMaxLineLength = (\n  state: State,\n  unparsedMaxLineLength: string,\n) => {\n  const maxLineLength = parseInt(unparsedMaxLineLength);\n  if (isNaN(maxLineLength)) return { ...state };\n  const { indentation } = state;\n  if (maxLineLength < indentation) {\n    return { ...state, maxLineLength: indentation };\n  }\n  return { ...state, maxLineLength };\n};\n\nconst handleSetShouldPlaceDotsAfterLineBreaks = (\n  state: State,\n  shouldPlaceDotsAfterLineBreaks: boolean,\n) => ({ ...state, shouldPlaceDotsAfterLineBreaks });\n\nconst reducers = {\n  [SET_QUERY_INPUT]: handleSetQueryInput,\n  [FORMAT_QUERY]: handleFormatQuery,\n  [TOGGLE_SHOULD_SHOW_ADVANCED_OPTIONS]: handleToggleShouldShowAdvancedOptions,\n  [SET_INDENTATION]: handleSetIndentation,\n  [SET_MAX_LINE_LENGTH]: handleSetMaxLineLength,\n  [SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS]: handleSetShouldPlaceDotsAfterLineBreaks,\n};\n\nexport default reducers;\n","import { dispatch } from '../libs/reduced-state';\nimport {\n  SET_QUERY_INPUT,\n  FORMAT_QUERY,\n  SET_INDENTATION,\n  SET_MAX_LINE_LENGTH,\n  SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS,\n} from './actions';\n\nconst handleSetQueryInput = () => dispatch(FORMAT_QUERY);\nconst handleSetIndentation = () => dispatch(FORMAT_QUERY);\nconst handleSetMaxLineLength = () => dispatch(FORMAT_QUERY);\nconst handleSetShouldPlaceDotsAfterLineBreaks = () => dispatch(FORMAT_QUERY);\n\nconst routines = {\n  [SET_QUERY_INPUT]: handleSetQueryInput,\n  [SET_INDENTATION]: handleSetIndentation,\n  [SET_MAX_LINE_LENGTH]: handleSetMaxLineLength,\n  [SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS]: handleSetShouldPlaceDotsAfterLineBreaks,\n};\n\nexport default routines;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { inputTextColor } from '../styleVariables';\n\nconst QueryInputWrapper = styled.div`\n  padding: 10px;\n`;\n\nconst QueryInputTextArea = styled.textarea`\n  height: calc(100vh / 4);\n  border-radius: 5px;\n  font-family: 'Courier New', Courier, monospace;\n  background: rgba(0, 0, 0, 0.05);\n  outline: none;\n  font-size: 16px;\n  padding: 10px;\n  border: none;\n  resize: none;\n  width: 100%;\n  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;\n  color: ${inputTextColor};\n  box-sizing: border-box;\n`;\n\ntype QueryInputProps = {\n  onChange?: ((event: React.ChangeEvent<HTMLTextAreaElement>) => void) | undefined;\n  value: string;\n};\n\nconst QueryInput = ({ onChange, value }: QueryInputProps) => (\n  <QueryInputWrapper>\n    <QueryInputTextArea onChange={onChange} value={value} rows={25} />\n  </QueryInputWrapper>\n);\n\nexport default QueryInput;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { highlightedTextColor, textColor } from '../styleVariables';\n\nconst TextButtonWrapper = styled.span`\n  display: inline-block;\n  padding: 10px;\n  box-sizing: border-box;\n`;\n\nconst TextButtonButton = styled.button`\n  height: 20px;\n  line-height: 20px;\n  font-size: 15px;\n  color: ${textColor};\n  &: {\n    color: ${highlightedTextColor};\n  }\n  background: none;\n  border: none;\n  cursor: pointer;\n  padding: 0;\n  outline: none;\n`;\n\ntype TextButtonProps = {\n  label: string;\n  onClick: VoidFunction;\n};\n\nconst TextButton = ({ label, onClick }: TextButtonProps) => (\n  <TextButtonWrapper>\n    <TextButtonButton onClick={onClick}>{label}</TextButtonButton>\n  </TextButtonWrapper>\n);\n\nexport default TextButton;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { HTMLAttributes } from 'react';\nimport { disabledTextColor, textColor } from '../styleVariables';\n\nconst CodePreviewWrapper = styled.div`\n  padding: 10px;\n`;\n\nconst CodePreviewBox = styled.div`\n  border-radius: 5px;\n  font-family: 'Courier New', Courier, monospace;\n  background: rgba(0, 0, 0, 0.05);\n  outline: none;\n  font-size: 15px;\n  padding: 10px;\n  border: none;\n  resize: none;\n  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;\n  white-space: pre-wrap;\n  overflow: auto;\n  position: relative;\n`;\n\nconst Code = styled.div`\n  color: ${textColor};\n  line-height: 20px;\n  font-size: 15px;\n`;\n\nconst CodeRuler = styled.div<{ $maxLineLength: number }>`\n  top: 0;\n  left: 0;\n  width: calc(10px + ${({ $maxLineLength }) => $maxLineLength}ch);\n  border-right: 1px solid ${disabledTextColor};\n  position: absolute;\n  height: 100%;\n  pointer-events: none;\n`;\n\ntype CodePreviewProps = {\n  maxLineLength?: number;\n} & HTMLAttributes<HTMLSpanElement>;\n\nconst CodePreview = ({ maxLineLength, children }: CodePreviewProps) => (\n  <CodePreviewWrapper>\n    <CodePreviewBox>\n      <Code>{children}</Code>\n      {maxLineLength ? <CodeRuler $maxLineLength={maxLineLength} /> : null}\n    </CodePreviewBox>\n  </CodePreviewWrapper>\n);\n\nexport default CodePreview;\n","import { useEffect, useState } from 'react';\nimport { ReducedState } from './types';\n\nexport const useReducedState = <T>(reducedState: ReducedState<T>) => {\n  const [state, setState] = useState<T>(reducedState.state);\n\n  useEffect(() => {\n    const changeListener = (state: T) => {\n      setState(state);\n    };\n    reducedState.addChangeListener(changeListener);\n    return () => reducedState.removeChangeListener(changeListener);\n  }, [reducedState]);\n\n  return state;\n};\n","import React from 'react';\nimport styled from 'styled-components';\nimport {\n  borderColor,\n  highlightedTextColor,\n  textColor,\n  white,\n} from '../styleVariables';\n\nconst ToggleContainer = styled.span<{ $width: string; $height: string }>`\n  display: inline-block;\n  height: ${({ $height }) => $height};\n  width: ${({ $width }) => $width};\n  border-radius: 5px;\n  background: rgba(0, 0, 0, 0.05);\n  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;\n  position: relative;\n`;\n\nconst Option = styled.span<{ $width: string; $height: string }>`\n  cursor: pointer;\n  display: inline-block;\n  height: ${({ $height }) => $height};\n  width: calc(${({ $width }) => $width} / 2);\n  box-sizing: border-box;\n  padding: 10px;\n  line-height: 20px;\n  font-size: 16px;\n  color: ${textColor};\n  text-align: center;\n`;\n\nconst SelectedOption = styled.span<{ $checked: boolean }>`\n  background: ${white};\n  cursor: pointer;\n  display: inline-block;\n  position: absolute;\n  top: 0;\n  left: ${({ $checked }) => ($checked ? '160px' : '0')};\n  height: 40px;\n  width: 160px;\n  border-radius: 5px;\n  box-sizing: border-box;\n  padding: 10px;\n  line-height: 20px;\n  font-size: 16px;\n  color: ${highlightedTextColor};\n  text-align: center;\n  border: 1px solid ${borderColor};\n  transition: 0.5s;\n`;\n\ntype ToggleProps = {\n  width: string;\n  height: string;\n  checked: boolean;\n  labels: { checked: string; unchecked: string };\n  onChange: (checked: boolean) => void;\n};\n\nconst Toggle = ({\n  width = '320px',\n  height = '40px',\n  checked = false,\n  labels = { checked: 'Checked', unchecked: 'Unchecked' },\n  onChange,\n}: ToggleProps) => (\n  <ToggleContainer $width={width} $height={height}>\n    <Option $width={width} $height={height} onClick={() => onChange(false)}>\n      {labels.unchecked}\n    </Option>\n    <Option $width={width} $height={height} onClick={() => onChange(true)}>\n      {labels.checked}\n    </Option>\n    <SelectedOption $checked={checked}>\n      {checked ? labels.checked : labels.unchecked}\n    </SelectedOption>\n  </ToggleContainer>\n);\n\nexport default Toggle;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { dispatch } from '../../libs/reduced-state';\nimport { useReducedState } from '../../libs/reduced-state/useReducedState';\nimport store from '../../store';\nimport {\n  SET_INDENTATION,\n  SET_MAX_LINE_LENGTH,\n  SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS,\n} from '../../store/actions';\nimport { inputTextColor, textColor } from '../../styleVariables';\nimport Toggle from '../../components/Toggle';\n\nconst AdvancedOptionRowWrapper = styled.div`\n  padding: 10px;\n`;\n\nconst AdvancedOptionLabel = styled.div`\n  height: 20px;\n  line-height: 20px;\n  font-size: 15px;\n  color: ${textColor};\n`;\n\nconst AdvancedOptionInput = styled.input`\n  border-radius: 5px;\n  background: rgba(0, 0, 0, 0.05);\n  outline: none;\n  font-size: 16px;\n  padding: 10px;\n  border: none;\n  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;\n  color: ${inputTextColor};\n  display: inline-block;\n  vertical-align: bottom;\n  box-sizing: border-box;\n  height: 40px;\n  width: 320px;\n`;\n\nconst AdvancedOptions = () => {\n  const state = useReducedState(store);\n  return (\n    <div>\n      <AdvancedOptionRowWrapper>\n        <AdvancedOptionLabel>Indentation</AdvancedOptionLabel>\n        <AdvancedOptionInput\n          type=\"number\"\n          min={0}\n          max={state.maxLineLength}\n          value={state.indentation}\n          onChange={({ target }) => {\n            dispatch(SET_INDENTATION, target.value);\n          }}\n        />\n      </AdvancedOptionRowWrapper>\n      <AdvancedOptionRowWrapper>\n        <AdvancedOptionLabel>Max line length</AdvancedOptionLabel>\n        <AdvancedOptionInput\n          type=\"number\"\n          min={state.indentation}\n          value={state.maxLineLength}\n          onChange={({ target }) => {\n            dispatch(SET_MAX_LINE_LENGTH, target.value);\n          }}\n        />\n      </AdvancedOptionRowWrapper>\n      <AdvancedOptionRowWrapper>\n        <AdvancedOptionLabel>Dot placement</AdvancedOptionLabel>\n        <Toggle\n          height=\"40px\"\n          width=\"320px\"\n          checked={state.shouldPlaceDotsAfterLineBreaks}\n          labels={{\n            checked: 'After line break',\n            unchecked: 'Before line break',\n          }}\n          onChange={(shouldPlaceDotsAfterLineBreaks) => {\n            dispatch(\n              SET_SHOULD_PLACE_DOTS_AFTER_LINE_BREAKS,\n              shouldPlaceDotsAfterLineBreaks,\n            );\n          }}\n        />\n      </AdvancedOptionRowWrapper>\n    </div>\n  );\n};\n\nexport default AdvancedOptions;\n","import React from 'react';\nimport styled from 'styled-components';\nimport store from '../../store';\nimport QueryInput from '../../components/QueryInput';\nimport TextButton from '../../components/TextButton';\nimport CodePreview from '../../components/CodePreview';\nimport AdvancedOptions from './AdvancedOptions';\nimport { State } from '../../store/types';\nimport { dispatch } from '../../libs/reduced-state';\nimport { useReducedState } from '../../libs/reduced-state/useReducedState';\nimport {\n  SET_QUERY_INPUT,\n  TOGGLE_SHOULD_SHOW_ADVANCED_OPTIONS,\n} from '../../store/actions';\n\nconst ExpandableAdvancedOptionsWrapper = styled.div<{ $isExpanded: boolean }>`\n  max-height: ${({ $isExpanded }) => ($isExpanded ? '240px' : '0')};\n  box-shadow: inset white 0 0 10px 0;\n  overflow: hidden;\n  transition: 0.5s;\n`;\n\nconst QueryFormatter = () => {\n  const state = useReducedState<State>(store);\n  return (\n    <div>\n      <QueryInput\n        value={state.queryInput}\n        onChange={({ target }) => dispatch(SET_QUERY_INPUT, target.value)}\n      />\n      <TextButton\n        label={\n          state.shouldShowAdvancedOptions\n            ? 'Hide advanced options'\n            : 'Show advanced options'\n        }\n        onClick={() => dispatch(TOGGLE_SHOULD_SHOW_ADVANCED_OPTIONS)}\n      />\n      <ExpandableAdvancedOptionsWrapper\n        $isExpanded={state.shouldShowAdvancedOptions}\n      >\n        <AdvancedOptions />\n      </ExpandableAdvancedOptionsWrapper>\n      {state.queryOutput ? (\n        <CodePreview maxLineLength={state.maxLineLength}>\n          {state.queryOutput}\n        </CodePreview>\n      ) : null}\n    </div>\n  );\n};\n\nexport default QueryFormatter;\n","import React from 'react';\nimport styled, { css } from 'styled-components';\nimport { HTMLAttributes } from 'react';\nimport { textColor } from '../styleVariables';\n\nconst ParagraphWrapper = styled.div<{ $hasContent: boolean }>`\n  ${({ $hasContent }) =>\n    $hasContent &&\n    css`\n      padding: 10px;\n    `}\n`;\n\nconst ParagraphContent = styled.span`\n  color: ${textColor};\n  line-height: 20px;\n  font-size: 15px;\n`;\n\nconst Paragraph = ({ children }: HTMLAttributes<HTMLSpanElement>) => (\n  <ParagraphWrapper $hasContent={Boolean(children)}>\n    <ParagraphContent>{children}</ParagraphContent>\n  </ParagraphWrapper>\n);\n\nexport default Paragraph;\n","import React from 'react';\nimport styled, { css } from 'styled-components';\nimport { HTMLAttributes } from 'react';\nimport { textColor } from '../styleVariables';\n\nconst TitleWrapper = styled.div<{ $hasContent: boolean }>`\n  ${({ $hasContent }) =>\n    $hasContent &&\n    css`\n      padding: 10px;\n    `}\n`;\n\nconst TitleContent = styled.div`\n  color: ${textColor};\n  line-height: 30px;\n  font-size: 25px;\n`;\n\nconst Title = ({ children }: HTMLAttributes<HTMLDivElement>) => (\n  <TitleWrapper $hasContent={Boolean(children)}>\n    <TitleContent>{children}</TitleContent>\n  </TitleWrapper>\n);\n\nexport default Title;\n","import styled from 'styled-components';\n\nconst Spacer = styled.div`\n  height: 20px;\n`;\n\nexport default Spacer;\n","import React from 'react';\nimport Paragraph from './Paragraph';\nimport Title from './Title';\nimport CodePreview from './CodePreview';\nimport Spacer from './Spacer';\n\ntype StyleGuideRuleProps = {\n  title: string;\n  explanation: string;\n  example: string;\n};\n\nconst StyleGuideRule = ({\n  title,\n  explanation,\n  example,\n}: StyleGuideRuleProps) => (\n  <div>\n    <Title>{title}</Title>\n    <Paragraph>{explanation}</Paragraph>\n    <CodePreview>{example}</CodePreview>\n    <Spacer />\n  </div>\n);\n\nexport default StyleGuideRule;\n","export const rules = [\n  {\n    title: 'Break long queries into multiple lines',\n    explanation: `What is considered too long depends on your application.\nWhen breaking the query, not all parts of the traversal have to be broken up. First, divide the query into logical groups, based on which steps belong naturally together. For instance, every set of steps which end with an as()-step often belong together, as they together form a new essential step in the query.\n    \nIf anoymous traversals are passed as arguments to another step, like a filter()-step, and it's causing the line to be too long, first split the line at the commas. Only if the traversal arguments are still too long, consider splitting them further.`,\n    example: `// Good (80 characters max width)\ng.V().hasLabel('person').where(outE(\"created\").count().is(P.gte(2))).count()\n    \n// Good (50 characters max width)\ng.V().\n  hasLabel('person').\n  where(outE(\"created\").count().is(P.gte(2))).\n  count()\n    \n// Good (30 characters max width)\ng.V().\n  hasLabel('person').\n  where(\n    outE(\"created\").\n    count().\n    is(P.gte(2))).\n  count()`,\n  },\n  {\n    title: 'Use soft tabs (spaces) for indentation',\n    explanation:\n      'This ensures that your code looks the same for anyone, regardless of their text editor settings.',\n    example: `// Bad - indented using hard tabs\ng.V().\n  hasLabel('person').as('person').\n  properties('location').as('location').\n  select('person','location').\n    by('name').\n    by(valueMap())\n    \n// Good - indented using spaces\ng.V().\nhasLabel('person').as('person').\nproperties('location').as('location').\nselect('person','location').\nby('name').\nby(valueMap())`,\n  },\n  {\n    title: 'Use two spaces for indentation',\n    explanation:\n      'Two spaces makes the intent of the indent clear, but does not waste too much space. Of course, more spaces are allowed when indenting from an already indented block of code.',\n    example: `// Bad - Indented using four spaces\ng.V().\n    hasLabel('person').as('person').\n    properties('location').as('location').\n    select('person','location').\n        by('name').\n        by(valueMap())\n// Good - Indented using two spaces\ng.V().\n  hasLabel('person').as('person').\n  properties('location').as('location').\n  select('person','location').\n    by('name').\n    by(valueMap())`,\n  },\n  {\n    title: 'Use indents wisely',\n    explanation: `No newline should ever have the same indent as the line starting with the traversal source g.\nUse indents when the step in the new line is a modulator of a previous line.\nUse indents when the content in the new line is an argument of a previous step.\nIf multiple anonymous traversals are passed as arguments to a function, each newline which is not the first step of the traversal should be indented to make it more clear where the distinction between each argument goes. If this is the case, but the newline would already be indented because the step in the content in the new line is the argument of a previous step, there is no need to double-indent.\nDon't be tempted to add extra indentation to vertically align a step with a step in a previous line.`,\n    example: `// Bad - No newline should have the same indent as the line starting with the traversal source g\ng.V().\ngroup().\nby().\nby(bothE().count())\n// Bad - Modulators of a step on a previous line should be indented\ng.V().\n  group().\n  by().\n  by(bothE().count())\n// Good\ng.V().\n  group().\n    by().\n    by(bothE().count())\n// Bad - You have ignored the indent rules to achieve the temporary satisfaction of vertical alignment\ng.V().local(union(identity(),\n                  bothE().count()).\n            fold())\n// Good\ng.V().\n  local(\n    union(\n      identity(),\n      bothE().count()).\n    fold())\n// Bad - When multiple anonymous traversals are passed as arguments to a function, each newline which is not the first of line of the step should be indented to make it more clear where the distinction between each argument goes.\ng.V().\n  has('person','name','marko').\n  fold().\n  coalesce(\n    unfold(),\n    addV('person').\n    property('name','marko').\n    property('age',29))\n// Good - We make it clear that the coalesce step takes two traversals as arguments\ng.V().\n  has('person','name','marko').\n  fold().\n  coalesce(\n    unfold(),\n    addV('person').\n      property('name','marko').\n      property('age',29))`,\n  },\n  {\n    title: 'Keep as()-steps at the end of each line',\n    explanation: `The end of the line is a natural place to assign a label to a step. It's okay if the as()-step is in the middle of the line if there are multiple consecutive label assignments, or if the line is so short that a newline doesn't make sense. Maybe a better way to put it is to not start a line with an as()-step, unless you're using it inside a match()-step of course.`,\n    example: `// Bad\ng.V().\n  as('a').\n  out('created').\n  as('b').\n  select('a','b')\n// Good\ng.V().as('a').\n  out('created').as('b').\n  select('a','b')\n// Good\ng.V().as('a').out('created').as('b').select('a','b')`,\n  },\n  {\n    title: 'Add linebreak after punctuation, not before',\n    explanation: `While adding the linebreak before the punctuation looks good in most cases, it introduces alignment problems when not all lines start with a punctuation. You never know if the next line should be indented relative to the punctuation of the previous line or the method of the previous line. Switching between having the punctuation at the start or the end of the line depending on whether it works in a particular case requires much brainpower (which we don't have), so it's better to be consistent. Adding the punctuation before the linebreak also means that you can know if you have reached the end of the query without reading the next line.`,\n    example: `// Bad - Looks okay, though\ng.V().has('name','marko')\n     .out('knows')\n     .has('age', gt(29))\n     .values('name')\n// Good\ng.V().\n  has('name','marko').\n  out('knows').\n  has('age', gt(29)).\n  values('name')\n// Bad - Punctuation at the start of the line makes the transition from filter to select to count too smooth\ng.V()\n  .hasLabel(\"person\")\n  .group()\n    .by(values(\"name\", \"age\").fold())\n  .unfold()\n  .filter(\n    select(values)\n    .count(local)\n    .is(gt(1)))\n// Good - Keeping punctuation at the end of each line, more clearly shows the query structure\ng.V().\n  hasLabel(\"person\").\n  group().\n    by(values(\"name\", \"age\").fold()).\n  unfold().\n  filter(\n    select(values).\n    count(local).\n    is(gt(1)))`,\n  },\n  {\n    title:\n      'Add linebreak and indentation for nested traversals which are long enough to span multiple lines',\n    explanation: '',\n    example: `// Bad - Not newlining the first argument of a function whose arguments span over multipe lines causes the arguments to not align.\ng.V().\n  hasLabel(\"person\").\n  groupCount().\n    by(values(\"age\").\n      choose(is(lt(28)),\n        constant(\"young\"),\n        choose(is(lt(30)),\n          constant(\"old\"),\n          constant(\"very old\"))))\n// Bad - We talked about this in the indentation section, didn't we?\ng.V().\n  hasLabel(\"person\").\n  groupCount().\n    by(values(\"age\").\n       choose(is(lt(28)),\n              constant(\"young\"),\n              choose(is(lt(30)),\n                     constant(\"old\"),\n                     constant(\"very old\"))))\n// Good\ng.V().\n  hasLabel(\"person\").\n  groupCount().\n    by(\n      values(\"age\").\n      choose(\n        is(lt(28)),\n        constant(\"young\"),\n        choose(\n          is(lt(30)),\n          constant(\"old\"),\n          constant(\"very old\"))))`,\n  },\n  {\n    title:\n      'Place all trailing parentheses on a single line instead of distinct lines',\n    explanation:\n      'Aligning the end parenthesis with the step to which the start parenthesis belongs might make it easier to check that the number of parentheses is correct, but looks ugly and wastes a lot of space.',\n    example: `// Bad\ng.V().\n  hasLabel(\"person\").\n  groupCount().\n    by(\n      values(\"age\").\n      choose(\n        is(lt(28)),\n        constant(\"young\"),\n        choose(\n          is(lt(30)),\n          constant(\"old\"),\n          constant(\"very old\")\n        )\n      )\n    )\n// Good\ng.V().\n  hasLabel(\"person\").\n  groupCount().\n    by(\n      values(\"age\").\n      choose(\n        is(lt(28)),\n        constant(\"young\"),\n        choose(\n          is(lt(30)),\n          constant(\"old\"),\n          constant(\"very old\"))))`,\n  },\n  {\n    title:\n      'Use // for single line comments. Place single line comments on a newline above the subject of the comment.',\n    explanation: '',\n    example: `// Bad\ng.V().\n  has('name','alice').out('bought'). // Find everything that Alice has bought\n  in('bought').dedup().values('name') // Find everyone who have bought some of the same things as Alice\n// Good\ng.V().\n  // Find everything that Alice has bought\n  has('name','alice').out('bought').\n  // Find everyone who have bought some of the same things as Alice\n  in('bought').dedup().values('name')`,\n  },\n  {\n    title: 'Use single quotes for strings',\n    explanation:\n      'Use single quotes for literal string values. If the string contains double quotes or single quotes, surround the string with the type of quote which creates the fewest escaped characters.',\n    example: `// Bad - Use single quotes where possible\ng.V().has(\"Movie\", \"name\", \"It's a wonderful life\")\n// Bad - Escaped single quotes are even worse than double quotes\ng.V().has('Movie', 'name', 'It\\\\'s a wonderful life')\n// Good\ng.V().has('Movie', 'name', \"It's a wonderful life\")`,\n  },\n  {\n    title: 'Write idiomatic Gremlin code',\n    explanation: `If there is a simpler way, do it the simpler way. Use the Gremlin methods for what they're worth.`,\n    example: `// Bad\ng.V().outE().inV()\n// Good\ng.V().out()\n// Bad\ng.V().\n  has('name', 'alice').\n  outE().hasLabel('bought').inV().\n  values('name')\n// Good\ng.V().\n  has('name','alice').\n  out('bought').\n  values('name')\n// Bad\ng.V().hasLabel('person').has('name', 'alice')\n// Good\ng.V().has('person', 'name', 'alice')`,\n  },\n];\n","import React from 'react';\nimport StyleGuideRule from '../../components/StyleGuideRule';\nimport { rules } from './rules';\n\nconst StyleGuide = () => (\n  <div>\n    {rules.map(({ title, explanation, example }) => (\n      <StyleGuideRule\n        key={title}\n        title={title}\n        explanation={explanation}\n        example={example}\n      />\n    ))}\n  </div>\n);\n\nexport default StyleGuide;\n","import React, { useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { white } from '../styleVariables';\n\nconst LoadingAnimationWrapper = styled.div`\n  position: fixed;\n  background: ${white};\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 2;\n`;\n\nconst GrayscaleImageWrapper = styled.div`\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  bottom: calc(50vh - 25vmin);\n`;\n\nconst ColoredImageWrapper = styled.div<{ $loadingCompletion: number }>`\n  overflow: hidden;\n  height: ${({ $loadingCompletion }) => $loadingCompletion / 2}vmin;\n  width: 100%;\n  position: absolute;\n  bottom: calc(50vh - 25vmin);\n`;\n\nconst Image = styled.img<{ $opacity: number }>`\n  opacity: ${({ $opacity }) => $opacity};\n  transition: 0.25s;\n  height: 50vmin;\n  width: 50vmin;\n  display: block;\n  margin: auto;\n  position: absolute;\n  bottom: 0;\n  left: 50%;\n  transform: translate(-50%, 0);\n`;\n\ntype LoadingAnimationProps = {\n  onLoadingComplete: VoidFunction;\n};\n\nconst LoadingAnimation = ({ onLoadingComplete }: LoadingAnimationProps) => {\n  const [loadingCompletion, setLoadingCompletion] = useState(0);\n  const [coloredImageHasLoaded, setColoredImageHasLoaded] = useState(false);\n  const [grayscaleImageHasLoaded, setGrayscaleImageHasLoaded] = useState(false);\n\n  useEffect(() => {\n    setTimeout(\n      () => {\n        if (loadingCompletion < 100) {\n          if (coloredImageHasLoaded && grayscaleImageHasLoaded) {\n            setLoadingCompletion(loadingCompletion + 1);\n          }\n        } else {\n          setTimeout(onLoadingComplete, 250);\n        }\n      },\n      loadingCompletion === 0 ? 250 : 10,\n    );\n  }, [\n    loadingCompletion,\n    coloredImageHasLoaded,\n    grayscaleImageHasLoaded,\n    onLoadingComplete,\n  ]);\n\n  return (\n    <LoadingAnimationWrapper>\n      <GrayscaleImageWrapper>\n        <Image\n          src=\"https://gremlint.com/wp-content/uploads/2020/07/Lowpoly-Gremlin-with-Text-Grayscale-1080x1080-1.png\"\n          $opacity={\n            grayscaleImageHasLoaded && loadingCompletion !== 100 ? 1 : 0\n          }\n          onLoad={() => setGrayscaleImageHasLoaded(true)}\n        />\n      </GrayscaleImageWrapper>\n      <ColoredImageWrapper $loadingCompletion={loadingCompletion}>\n        <Image\n          src=\"https://gremlint.com/wp-content/uploads/2020/07/Lowpoly-Gremlin-with-Text-1080x1080-1.png\"\n          $opacity={loadingCompletion !== 100 ? 1 : 0}\n          onLoad={() => setColoredImageHasLoaded(true)}\n        />\n      </ColoredImageWrapper>\n    </LoadingAnimationWrapper>\n  );\n};\n\nexport default LoadingAnimation;\n","import React, { useState } from 'react';\nimport './App.css';\nimport styled from 'styled-components';\nimport { useRouter } from 'sharp-router';\nimport router from './router';\nimport FadeIn from './components/FadeIn';\nimport Navigator from './components/Navigator';\nimport QueryFormatter from './views/QueryFormatter';\nimport StyleGuide from './views/StyleGuide';\nimport LoadingAnimation from './components/LoadingAnimation';\n\nconst ViewWrapper = styled.div`\n  width: min(800px, 100vw);\n  margin-left: calc(50vw - min(400px, 50vw));\n`;\n\nconst App = () => {\n  const { matchedRoute } = useRouter(router);\n  const [loadingComplete, setLoadingComplete] = useState(false);\n  if (!loadingComplete)\n    return (\n      <LoadingAnimation onLoadingComplete={() => setLoadingComplete(true)} />\n    );\n  return (\n    <FadeIn>\n      <div>\n        <Navigator matchedRoute={matchedRoute} />\n        <div>\n          <ViewWrapper>\n            {matchedRoute === '/' ? (\n              <QueryFormatter />\n            ) : matchedRoute === '/style-guide' ? (\n              <StyleGuide />\n            ) : null}\n          </ViewWrapper>\n        </div>\n      </div>\n    </FadeIn>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}